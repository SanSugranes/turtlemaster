<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <link href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://unpkg.com/three@0.87.1/build/three.js"></script>
    <script src="https://unpkg.com/three@0.87.1/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.87.1/examples/js/loaders/GLTFLoader.js"></script>
    <script src="./../js/turtle.js"></script>
    <script src="./../js/modules/main.js"></script>
    <script src="./../js/modules/eventDispatcher.js"></script>
    <script src="./../js/database.js"></script>
    <script src="./../js/lib/utf8.js"></script>
</head>

<body>
    <div id="WebGl-container" class="w-full">
        <div id="app-main" class="w-full"></div>
        <div id="app-overlay" class="w-full"></div>
    </div>
    <div class="direction">
        <button class="" onclick="turtle.move(MoveDirection.FRONT)">FRONT</button>
        <button class="" onclick="turtle.move(MoveDirection.BACK)">BACK</button>
        <button class="" onclick="turtle.move(MoveDirection.LEFT)">LEFT</button>
        <button class="" onclick="turtle.move(MoveDirection.RIGHT)">RIGHT</button>

        <button class="" onclick="turtle.move(MoveDirection.UP)">UP</button>
        <button class="" onclick="turtle.move(MoveDirection.DOWN)">DOWN</button>
        <button class="" onclick="clearGlobal()">CLEAR</button>
    </div>

    <script>
        var clearGlobal;
    </script>

    <script type="module">

        let camera, scene, renderer, turtleCube, turtleLineSegments, turtleInfos;

        //renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        //camera
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 100;

        init();
        animate();
        addWsListener(handleViewMessage);

        clearGlobal = function clear() {
            console.log("ASSdZTAFSDHGASDUZTAFSDZTFASDZTFASDZTFASDZTFASDZTFASDZTF");
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }

            init();
        }

        function init() {


            var storageObj = JSON.parse(localStorage.getItem('storageObj'));
            turtleInfos = storageObj.turtleInfos;


            const controls = new THREE.OrbitControls(camera, renderer.domElement);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0a0a0);

            const light = new THREE.AmbientLight(0x404040); // soft white light
            scene.add(light);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            scene.add(directionalLight);

            // Turtle
            var geometry = new THREE.BoxGeometry(1, 1, 1);
            var material = new THREE.MeshToonMaterial({ color: 0xff0000 });
            turtleCube = new THREE.Mesh(geometry, material);
            var lineMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                linewidth: 1,
                linecap: 'round', //ignored by WebGLRenderer
                linejoin: 'round' //ignored by WebGLRenderer
            });

            turtleLineSegments = new THREE.LineSegments(geometry, lineMaterial);

            turtleCube.position.set(turtleInfos.position.x, turtleInfos.position.y, turtleInfos.position.z);

            turtleLineSegments.position.set(turtleInfos.position.x, turtleInfos.position.y, turtleInfos.position.z);

            scene.add(turtleCube);
            scene.add(turtleLineSegments);

            storageObj.database.forEach(block => {
                createBlock(block);
            });

            var skyboxGeometry = new THREE.BoxGeometry(10000, 10000, 10000);
            var skyboxMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide });
            var skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);

            scene.add(skybox);

            const loader = new THREE.GLTFLoader();
            loader.crossOrigin = true;
            loader.load('../turtle.glb', function (data) {
                var object = data.scene;
                object.position.set(0, -10, -0.75);
                //     object.rotation.set(Math.PI / -2, 0, 0);

                //     TweenLite.from( object.rotation, 1.3, {
                //       y: Math.PI * 2,
                //       ease: 'Power3.easeOut'
                //     });

                TweenMax.from(object.position, 3, {
                    y: -8,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Power2.easeInOut'
                });
                //object.position.y = - 95;
                scene.add(object);
                //, onProgress, onError );
            });

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function addBlockToView(block) {
            createBlock(block);
        }

        function handleViewMessage(e) {
            var data = JSON.parse(e.data);

            switch (data.type) {
                case "mapInfos":
                    var infos = data.message;
                    if (infos.blockInfo != undefined) {

                        if (infos.blockInfo != "No block to inspect") {

                            var block = {
                                name: infos.blockInfo.name,
                                position: { x: infos.blockPos.x, y: infos.blockPos.y, z: infos.blockPos.z }
                            }

                            addBlockToView(block);
                        }
                    }
                    else if (infos.position != undefined) {

                        turtle.updateTurtle(infos);

                        turtleInfos = turtle.getTurtle();

                        drawTurtle();
                    }
                    break;
            }
        }

        function createBlock(block) {
            var geometry = new THREE.BoxBufferGeometry(1, 1, 1);


            var cubeHue = hexToHSL(stringToHex(block.name));
            console.log(cubeHue);
            var material = new THREE.MeshToonMaterial({ color: new THREE.Color('hsl(' + cubeHue['h'] * 360 + ', 100%, 30%)') });
            var cube = new THREE.Mesh(geometry, material);
            var lineMaterial = new THREE.LineBasicMaterial({
                color: 0x000000,
                linewidth: 1,
                linecap: 'round', //ignored by WebGLRenderer
                linejoin: 'round' //ignored by WebGLRenderer
            });
            var edges = new THREE.EdgesGeometry(geometry);
            var lineSegment = new THREE.LineSegments(edges, lineMaterial);


            cube.position.set(block.position.x, block.position.y, block.position.z);
            lineSegment.position.set(block.position.x, block.position.y, block.position.z);
            scene.add(cube);
            scene.add(lineSegment);
        }

        function stringToHex(str) {

            str = str.replace("minecraft:", "");

            str = ascii_to_hexa(str);

            str = str.substring(0, 6);

            if (str.length != 6) {
                do {
                    str += "0";
                } while (str.length != 6);
            }
            return str;
        }

        function drawTurtle() {
            turtleCube.position.set(turtleInfos.position.x, turtleInfos.position.y, turtleInfos.position.z);
            turtleLineSegments.position.set(turtleInfos.position.x, turtleInfos.position.y, turtleInfos.position.z);
        }

        document.addEventListener("keydown", (e) => {
            switch (e.key) {
                case "w":
                    turtle.move(MoveDirection.FRONT);
                    break;

                case "a":
                    turtle.move(MoveDirection.LEFT);
                    break;

                case "s":
                    turtle.move(MoveDirection.BACK);
                    break;

                case "d":
                    turtle.move(MoveDirection.RIGHT);
                    break;

                case " ": // space
                    turtle.move(MoveDirection.UP);
                    break;

                case "Shift":
                    turtle.move(MoveDirection.DOWN);
                    break;

                default:
                    console.log(e.key);
                    break;
            }
        });
    </script>

</body>

</html>